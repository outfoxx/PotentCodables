# Implementing New Formats

One of the stated goals of PotentCodables is to reduce the complexity and amount of code required when implementing new serialization
formats. We have achieved that goal only requiring new formats to implement the "boxing" and "unboxing" into their native value tree 
representation without regard for any of the inner working of Swit's `Codable` framework.

The following list of steps can be followed to easily implement a new serialization format.

## 1. Define a native value tree representation
Each provided implementation is built upon a native value tree in-memory representation; JSON uses the `JSON` values, CBOR uses `CBOR`
values, etc.  Examining any of the provided native value trees will reveal they closely mimic their serialized format.

### Required Protocols

- `Value`
The native value tree representation (usually an enum) **must** implement the `Value` protocol which provides null/nil testing and the
capability to "unwrap" themselves into a Swift primitive value tree.

### See/Examples

* `JSON`
The JSON native value tree is a great example of a full featured tree.
* `CBOR`
The CBOR native value tree is another great example of a full featured tree.

## 2. Provide a "serialization" type 
The next step requires you to provide a serialization class that can serialize native value trees into their final serialized representation and
conversely deserialize the serialized representation into a native value tree.

### Required Protocols
There are no required protocols for the serialization type to timplement because it will be used privately in the encoder and decoder
implementations.

### See/Example

* `JSONSerialization`
The JSONSerialization type serializes `JSON` values to/from `Data` values. Also, because JSON is a text based format, it supports serialization
to/from `String` values.
* `CBORSerialization`
The CBORSerialization type serializes `CBOR` values to/from `Data` values.

## 3. Provide "transformer" types
As the serialization type is used to translate from native value trees into their serialized forms, a "transformer" type transforms native value
trees to/from `Encodable`/`Decodable`. The good news here is that only the boxing and unboxing code is requried.

An encoding transformer and a decoding transformer are required. All of the protocols are prefixed with `Internal` to denote that they are
not intended for public use.

### Required Protocols (Encoding)

- `InternalEncoderTransform`
Provides the boxing of Swift primitives generated by `Encodable` instances.
- `InternalValueSerializer` - (only if format can target `Data` values)
If the serialization format supports targeting `Data` values then this protocol is required to be implemented.
- `InternalValueStringifier` - (only if format targets `String` values)
If the serialization format supports targeting `String` values then this protocol is required to be implemented.


### Required Protocols (Decoding)

- `InternalDecoderTransform`
Provides the unboxing of native value tree types.
- `InternalValueDeserializer` - (only if format targets `Data` values)
If the serialization format supports targeting `Data` values then this protocol is required to be implemented.
- `InternalValueParser` - (only if format targets `String` values)
If the serialization format supports targeting `String` values then this protocol is required to be implemented.

### See/Example

* `JSONEncoderTransform`/`JSONDecoderTransform`
* `CBOREncoderTransform`/`CBORDecoderTransform`


## 4. Create an "Encoder" and a "Decoder"
The final step is to implement the public encoder and decoder by deriving from the base implementations.

Encoders are created in the following manner:
```swift
struct MyFormatEncoder : ValueEncoder<MyFormat, MyFormatEncoderTransform> {...}
```

Decoders are created in the following manner:
```swift
struct MyFormatDecoder : ValueDecoder<MyFormat, MyFormatDecoderTransform> {...}
```

