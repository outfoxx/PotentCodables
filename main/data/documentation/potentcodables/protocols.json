{"hierarchy":{"paths":[["doc:\/\/PotentCodables\/documentation\/PotentCodables"]]},"abstract":[{"type":"text","text":"Details of all the protocols PotentCodables "},{"type":"codeVoice","code":"Encoder"},{"text":"s and ","type":"text"},{"type":"codeVoice","code":"Decoder"},{"text":"s implement.","type":"text"}],"identifier":{"url":"doc:\/\/PotentCodables\/documentation\/PotentCodables\/Protocols","interfaceLanguage":"swift"},"primaryContentSections":[{"content":[{"text":"Native Value Trees","level":2,"anchor":"Native-Value-Trees","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All PotentCodable encoders and decoders use a two stage serialization system. For example, when encoding an "},{"code":"Encodable","type":"codeVoice"},{"text":" value it is first","type":"text"},{"type":"text","text":" "},{"text":"transformed into a native “value tree” that is defined by the serialization format. Secondarily, a serialization utility is used to transform","type":"text"},{"text":" ","type":"text"},{"text":"the value tree into the final serialized data.","type":"text"}]},{"inlineContent":[{"type":"text","text":"For example, when encoding to CBOR the "},{"type":"codeVoice","code":"Encodable"},{"text":" value is first transformed into ","type":"text"},{"type":"codeVoice","code":"CBOR"},{"type":"text","text":" values that closely match the CBOR"},{"type":"text","text":" "},{"type":"text","text":"specification and then the "},{"type":"codeVoice","code":"CBOR"},{"type":"text","text":" value tree is serialized into "},{"type":"codeVoice","code":"Data"},{"text":".  The same process is done for decoding but in reverse, ","type":"text"},{"type":"codeVoice","code":"Data"},{"text":" is turned","type":"text"},{"text":" ","type":"text"},{"text":"into a value tree and then the value tree is decoded into a ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" value as requested."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This two stage system is important to ensure that we can implement new serialization formats with a reduced amount of code. All of the"},{"type":"text","text":" "},{"text":"machinery to encode ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"text":"s and  decode ","type":"text"},{"type":"codeVoice","code":"Decodable"},{"text":"s are isolated in a common set of classes that need to be implemented only","type":"text"},{"type":"text","text":" "},{"type":"text","text":"once."}]},{"inlineContent":[{"type":"text","text":"The protocol representing a native value tree is "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" and its quite small:"}],"type":"paragraph"},{"code":["  protocol Value {","    var isNull: Bool { get }","    var unwrapped: Any? { get }","  }"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"It provides only the ability to test if it represents something equivalent to Swift’s  ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" and the ability to “unwrap” itself into native Swift","type":"text"},{"type":"text","text":" "},{"type":"text","text":"values."}],"type":"paragraph"},{"inlineContent":[{"text":"You can see examples of ","type":"text"},{"code":"Value","type":"codeVoice"},{"type":"text","text":" implementations in the "},{"type":"codeVoice","code":"JSON"},{"text":" and ","type":"text"},{"code":"CBOR","type":"codeVoice"},{"text":" enumerations. These types closely track the values representable","type":"text"},{"type":"text","text":" "},{"text":"by thier format and can be easily manipulated.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Aside from providing code structure that allows us to employ code re-use this requirement ensures that we can always encode\/decode"},{"type":"text","text":" "},{"text":"to an in-memory value tree. A very useful side-effect of this is that it allows us to easily examine or manipulate everything that is encoded","type":"text"},{"type":"text","text":" "},{"text":"and decoded.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Note:"}]},{"type":"text","text":" Inevitably somebody will want to point out the inefficiency of using a two stage system of serialization. It is our belief that the added"},{"type":"text","text":" "},{"text":"features and reduced implementation cost far outweigh any slight performance\/memory improvement that might be gained from serializing","type":"text"},{"text":" ","type":"text"},{"text":"directly to the target format.  ","type":"text"},{"inlineContent":[{"type":"text","text":"Also"}],"type":"emphasis"},{"text":", Swift’s native JSON implementations already use this same two stage method. In the native","type":"text"},{"type":"text","text":" "},{"type":"text","text":"implementation, encodables are turned into Objective-C values and then Objective-C’s JSONSerialiazation class is used to create serialized"},{"type":"text","text":" "},{"text":"JSON data.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"Value-Tree-EncodingDecoding","level":2,"text":"Value Tree Encoding\/Decoding"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Due to the requirement that all of our encoders and decoders support a native value tree representation, it provides the capability to encode"},{"text":" ","type":"text"},{"type":"text","text":"or decode to native value trees using the following methods:"}]},{"anchor":"Protocols","level":4,"type":"heading","text":"Protocols"},{"type":"paragraph","inlineContent":[{"text":"Each encoder implements ","type":"text"},{"type":"codeVoice","code":"EncodesToTree"},{"type":"text","text":" and provides the following method with "},{"type":"codeVoice","code":"Value"},{"text":" being the ","type":"text"},{"code":"Encoder","type":"codeVoice"},{"type":"text","text":"’s native value tree type;"},{"type":"text","text":" "},{"text":"allowing us to transform an ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":" instance into a native value tree."}]},{"syntax":"swift","code":["protocol EncodesToTree {","  func encodeTree<T : Encodable, V : Value>(_ value: T) throws -> V","}"],"type":"codeListing"},{"inlineContent":[{"text":"Each decoder implements ","type":"text"},{"type":"codeVoice","code":"DecodesFromTree"},{"type":"text","text":" and provides the following methods with "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" being the "},{"code":"Decoder","type":"codeVoice"},{"text":"’s native value tree","type":"text"},{"text":" ","type":"text"},{"text":"type; allowing us to transform a native value tree into an instance of a ","type":"text"},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":" type."}],"type":"paragraph"},{"syntax":"swift","code":["protocol DecodesFromTree {","  func decodeTree<T : Decodable, V : Value>(_ type: T.Type, from: V) throws -> T","  func decodeTreeIfPresent<T : Decodable, V : Value>(_ type: T.Type, from: V) throws -> T?","}"],"type":"codeListing"},{"text":"Data Encoding\/Decoding","anchor":"Data-EncodingDecoding","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Binary formats, like "},{"type":"codeVoice","code":"CBOR"},{"text":", are encoded to their final form as a ","type":"text"},{"type":"codeVoice","code":"Data"},{"type":"text","text":" value. This is the interface most widely recognized from Swift’s native"},{"type":"text","text":" "},{"text":"implementations for JSON and Property List.","type":"text"}]},{"type":"heading","anchor":"Protocols","level":4,"text":"Protocols"},{"type":"paragraph","inlineContent":[{"text":"Each encoder implements ","type":"text"},{"type":"codeVoice","code":"EncodesToData"},{"type":"text","text":" and provides the following method to transform "},{"code":"Encodable","type":"codeVoice"},{"text":" instances into ","type":"text"},{"type":"codeVoice","code":"Data"},{"type":"text","text":" values."}]},{"code":["protocol EncodesToData {","  func encode<T: Encodable>(_ value: T) throws -> Data","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each decoder implements "},{"type":"codeVoice","code":"DecodesFromData"},{"type":"text","text":" and provides the following methods to transform "},{"code":"Data","type":"codeVoice"},{"text":" into an instance of a ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" "},{"text":"type.","type":"text"}]},{"syntax":"swift","code":["protocol DecodesFromData {","  func decode<T: Decodable>(_ type: T.Type, from: Data) throws -> T","  func decodeIfPresent<T: Decodable>(_ type: T.Type, from: Data) throws -> T?","}"],"type":"codeListing"},{"type":"heading","level":2,"text":"String Encoding\/Decoding","anchor":"String-EncodingDecoding"},{"type":"paragraph","inlineContent":[{"text":"Any PotentCodable encoder or decoder that is implementing a text based serialization format (e.g. JSON, YAML, etc.) provides the extra","type":"text"},{"type":"text","text":" "},{"type":"text","text":"capability to encode to and decode from "},{"code":"String","type":"codeVoice"},{"text":" values. These formats also support the methods for Data encoding\/decoding using a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"string encoding required by their speification or that will be automatically detected during decoding."}]},{"anchor":"Protocols","level":4,"type":"heading","text":"Protocols"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each encoder implements "},{"code":"EncodesToString","type":"codeVoice"},{"text":" and provides the following method to transform ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"text":" instances into ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" values.","type":"text"}]},{"syntax":"swift","code":["protocol EncodesToString {","  func encodeString<T: Encodable>(_ value: T) throws -> String","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Each decoder implements "},{"code":"DecodesFromString","type":"codeVoice"},{"type":"text","text":" and provides the following methods to transform "},{"code":"String","type":"codeVoice"},{"type":"text","text":" into an instance of a"},{"text":" ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" type."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["protocol DecodesFromString {","  func decode<T: Decodable>(_ type: T.Type, from: String) throws -> T","  func decodeIfPresent<T: Decodable>(_ type: T.Type, from: String) throws -> T","}"]},{"type":"heading","anchor":"Using-Protocols","level":2,"text":"Using Protocols"},{"inlineContent":[{"text":"Unlike Swift’s native encoders\/decoders, all the encoders and decoders provided by PotentCodables implement the above interfaces","type":"text"},{"type":"text","text":" "},{"type":"text","text":"based on the type of format (e.g. binary or text).  This allow users to interchangably use any encoder or decoder at runtime without munually"},{"text":" ","type":"text"},{"type":"text","text":"adding protocol conformance."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"One encoder\/decoder pair, "},{"code":"AnyValueEncoder","type":"codeVoice"},{"type":"text","text":"\/"},{"code":"AnyValueDecoder","type":"codeVoice"},{"type":"text","text":", only supports targeting native value trees. This is because it has no"},{"type":"text","text":" "},{"type":"text","text":"serialized format and only exists to transcode between in-memory representations."}],"type":"paragraph"}],"kind":"content"}],"sections":[],"kind":"article","seeAlsoSections":[{"generated":true,"anchor":"Advanced","title":"Advanced","identifiers":["doc:\/\/PotentCodables\/documentation\/PotentCodables\/PolymorphicEncodingDecoding","doc:\/\/PotentCodables\/documentation\/PotentCodables\/Custom-References","doc:\/\/PotentCodables\/documentation\/PotentCodables\/Implementing-Formats"]}],"metadata":{"role":"article","modules":[{"name":"PotentCodables"}],"title":"Encoder\/Decoder Protocols","roleHeading":"Article"},"schemaVersion":{"minor":3,"major":0,"patch":0},"references":{"doc://PotentCodables/documentation/PotentCodables/Custom-References":{"url":"\/documentation\/potentcodables\/custom-references","abstract":[{"text":"Polymorphic references tailored to your data.","type":"text"}],"role":"article","title":"Custom References","kind":"article","type":"topic","identifier":"doc:\/\/PotentCodables\/documentation\/PotentCodables\/Custom-References"},"doc://PotentCodables/documentation/PotentCodables":{"title":"PotentCodables","abstract":[{"type":"text","text":"A potent set of implementations and extensions to the Swift "},{"code":"Codable","type":"codeVoice"},{"text":" system","type":"text"}],"kind":"symbol","role":"collection","url":"\/documentation\/potentcodables","type":"topic","identifier":"doc:\/\/PotentCodables\/documentation\/PotentCodables"},"doc://PotentCodables/documentation/PotentCodables/PolymorphicEncodingDecoding":{"url":"\/documentation\/potentcodables\/polymorphicencodingdecoding","title":"Polymorphic Encoding & Decoding","abstract":[{"text":"Utilities to simplify polymorphic encoding and decoding.","type":"text"}],"kind":"article","type":"topic","role":"article","identifier":"doc:\/\/PotentCodables\/documentation\/PotentCodables\/PolymorphicEncodingDecoding"},"doc://PotentCodables/documentation/PotentCodables/Implementing-Formats":{"role":"article","abstract":[{"text":"Learn how to implement new ","type":"text"},{"code":"Codable","type":"codeVoice"},{"type":"text","text":" data formats easily."}],"type":"topic","identifier":"doc:\/\/PotentCodables\/documentation\/PotentCodables\/Implementing-Formats","title":"Implementing New Data Formats","url":"\/documentation\/potentcodables\/implementing-formats","kind":"article"}}}